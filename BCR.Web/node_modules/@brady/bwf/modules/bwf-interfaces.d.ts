/// <reference types="jquery" />
/// <reference types="kendo-ui" />
/// <reference types="knockout" />
/// <reference types="knockout.postbox" />
interface IGridColumnMetadata {
    abbreviatedName: string;
    additionalDescriptions: IKeyValuePair<string, string>[];
    alignment: string;
    customDisplayCell?: string;
    customEditingCell?: string;
    useCustomDisplayCell: boolean;
    useCustomEditingCell: boolean;
    customControlForEditMode?: string;
    defaultFormat: string;
    displayName: string;
    hasChoice: boolean;
    isNotEditableInGrid: boolean;
    isMandatoryInEditMode: boolean;
    isNullable: boolean;
    description: string;
    name: string;
    type: 'link' | 'download' | 'string' | 'type' | 'boolean' | 'measure' | 'integer' | 'numeric' | 'date' | 'time' | 'image' | 'enum';
    format?: string;
    dataService?: string;
    displayFieldInEditorChoice?: string;
    filteredOn?: string[];
    valueFieldInEditorChoice?: string;
    populateChoiceUrl?: string;
    populateChoiceQuery?: string;
    isEnum?: boolean;
    refreshChoiceOnChangesTo?: string;
    isDisabledInEditMode: boolean;
    isDisabledInCreateMode: boolean;
    _clrType?: string;
    _isType?: boolean;
}
interface IMetadataProperty extends IGridColumnMetadata {
    copyBehaviour: string;
    customCopyScript: string;
    customControl: string;
    customControlHeight: number;
    isCustomControlHeightAuto: boolean;
    customControlParameter: string;
    customDisplayCell: string;
    customEditingCell: string;
    dataService: string;
    defaultValue: any;
    displayFieldInEditorChoice: string;
    editingName: string;
    filteredOn: string[];
    format: string;
    fullName: string;
    heightInLines: number;
    identityProperties: string[];
    isEnum: boolean;
    isFreeFormat: boolean;
    isHidden: boolean;
    isHiddenInEditor: boolean;
    isNotEditableInPanel: boolean;
    isNotCreatableInPanel: boolean;
    parameterAllowNullOrEmpty: boolean;
    parameterAvailableOperators: IEnum[];
    parameterDefaultValue: string;
    parameterDisplayProperty: string;
    parameterQuery: string;
    parameterQueryDataService: string;
    populateChoiceUrl: string;
    populateChoiceQuery: string;
    positionInEditor: number;
    refreshChoiceOnChangesTo: string;
    isSelectorField: boolean;
    useCustomControl: boolean;
    valueFieldInEditorChoice: string;
    isDisabledInEditMode: boolean;
    isDisabledInCreateMode: boolean;
    isHiddenInEditMode: boolean;
    isHiddenInCreateMode: boolean;
    _abbreviatedWasEmpty: boolean;
    _clrType: string;
    _isCollection: boolean;
    _isType: boolean;
}
interface ITypeMetadata {
    autoUpdatesByDefault: boolean;
    dataService: string;
    displayName: string;
    expandsRequiredForEdit: string[];
    identityProperties: string[];
    identificationSummaryFields: string[];
    hasCompositeId: boolean;
    hasEditabilityToRoles: boolean;
    hasVisibilityToRoles: boolean;
    pluralisedDisplayName: string;
    properties: IDictionary<IMetadataProperty>;
    selectorFields: string[];
    supportsEditMode: boolean;
    supportsAggregations: boolean;
    insertableInEditMode: boolean;
    deletableInEditMode: boolean;
    type: string;
    resourcefulRoute: string;
    usesTypesFromOtherDataServices: boolean;
    useCombinedQuerier: boolean;
}
interface TypeMetadataRecord {
    AutoUpdatesByDefault: boolean;
    DataServiceName: string;
    DeletionDisabledInEditMode: boolean;
    DisplayName: string;
    ExpandsRequiredForEdit?: string;
    HasCompositeId?: boolean;
    HasEditabilityToRoles: boolean;
    HasVisibilityToRoles: boolean;
    IdentificationSummaryFields: string[];
    IdentityProperties: string[];
    InsertionDisabledInEditMode: boolean;
    PluralisedDisplayName?: string;
    Properties: PropertyRecord[];
    ResourcefulRoute: string;
    SelectorFields: string[];
    SupportsAggregations: boolean;
    SupportsEditMode: boolean;
    Type: string;
    UseCombinedQuerier: boolean;
    UsesTypesFromOtherDataServices: boolean;
}
interface PropertyRecord {
    AbbreviatedName?: string;
    AdditionalDescriptions?: IKeyValuePair<string, string>[];
    CopyBehaviour?: string;
    CustomControl?: string;
    CustomControlHeight?: number;
    CustomControlParameter?: string;
    CustomCopyScript?: string;
    CustomDisplayCell?: string;
    CustomEditingCell?: string;
    DefaultFormat?: string;
    DefaultValue: string;
    Description?: string;
    DisplayFieldInEditorChoice?: string;
    DisplayName: string;
    EditingName: string;
    FilteredOn?: string[];
    Format?: string;
    FromDataService?: string;
    HeightInLines?: number;
    IsCustomControlHeightAuto?: boolean;
    IsDisabledInCreateMode: boolean;
    IsDisabledInEditMode: boolean;
    IsHidden?: boolean;
    IsHiddenInCreateMode?: boolean;
    IsHiddenInEditMode?: boolean;
    IsHiddenInEditor?: boolean;
    IsFreeFormat?: boolean;
    IsMandatoryInEditMode?: boolean;
    IsNotCreatableInPanel?: boolean;
    IsNotEditableInGrid?: boolean;
    IsNotEditableInPanel?: boolean;
    IsNullable: boolean;
    Name: string;
    ParameterAllowNullOrEmpty?: boolean;
    ParameterAvailableOperators?: IEnum[];
    ParameterDefaultValue?: string;
    ParameterDisplayProperty?: string;
    ParameterQuery?: string;
    ParameterQueryDataService?: string;
    PopulateChoiceQuery?: string;
    PopulateChoiceUrl?: string;
    PositionInEditor?: number;
    PropertyType: string;
    RefreshChoiceOnChangesTo?: string;
    TypeName: string;
    UseCustomControl?: boolean;
    UseCustomDisplayCell?: boolean;
    UseCustomEditingCell?: boolean;
    ValueFieldInEditorChoice?: string;
}
interface IMetadataSource {
    addOrUpdateProperty(type: string, property: PropertyRecord): void;
    addOrUpdateTypes(records: TypeMetadataRecord[]): void;
    getType(name: string): JQueryPromise<ITypeMetadata>;
    hasType(name: string): boolean;
    hostUrl: string;
    metadataQueryUrl(type: string): string;
    name: string;
    removeProperty(type: string, property: string): void;
    setTypeProperties(type: string, properties: PropertyRecord[]): void;
    types: IDictionary<ITypeMetadata>;
    url: string;
    processMetadataItem(property: PropertyRecord): IMetadataProperty;
}
interface IMetaTypeDictionary {
    [index: string]: IMetadataSource;
}
interface IDictionary<T> {
    [index: string]: T;
}
interface IKeyValuePair<K, V> {
    Key: K;
    Value: V;
}
interface IMetadataService {
    generateNewRecord(metadata: ITypeMetadata): any;
    getAllDataServices(): IMetadataSource[];
    getAllDataServicesSafely(): JQueryPromise<IMetadataSource[]>;
    getDataService(dataService: string): IMetadataSource;
    getDataServiceSafely(dataService: string): JQueryPromise<IMetadataSource>;
    getEmptyGridColumnMetadata(): IGridColumnMetadata;
    getProperty(metadata: ITypeMetadata, propertyPath: string, overrides?: IDictionary<any>): IMetadataProperty;
    getAggregationProperty(aggMetadata: IAggregationFunctionDefinition, rootObject: ITypeMetadata, name: string, overrides: IDictionary<any>): IMetadataProperty;
    getPropertyWithPrefix(dataService: string, metadata: ITypeMetadata, propertyPath: string): IMetadataProperty;
    getType(dataService: string, typeName: string): JQueryPromise<ITypeMetadata>;
    hasDataService(dataService: string): boolean;
    hasType(dataService: string, typeName: string): boolean;
    isPropertyPathValid(dataService: string, typeMetadata: ITypeMetadata, path: string): boolean;
    isOrderByValid(typeMetadata: ITypeMetadata, orderBy: string): boolean;
    resourceUrl(metadataSource: IMetadataSource, typeMetadata: ITypeMetadata): string;
}
interface ILiveQueryExecutor {
    watchChanges: boolean;
    queryId: string;
    stop: () => void;
}
interface ArrayUtilities {
    findIndex: (source: any[], predicate: (any) => boolean) => number;
}
interface IGridUtilities {
    Array: ArrayUtilities;
    formatValue(value: any, type: string, defaultFormat: string): string;
    getLevenshteinDistance(left: string, right: string): number;
    parseValueWithUnit(input: string): IValueWithUnit;
    getSelectedCellText(cell: ISelectedCell): any;
    parseEditingBarText(cell: ISelectedCell, text: string): any;
    comparerFor(metadata: IMetadataProperty): (x, y) => boolean;
    constructChoiceUrlFromCell(typeMetadata: ITypeMetadata, cell: ISelectedCell, options: any): string;
    constructChoiceUrl(typeMetadata: ITypeMetadata, propertyMetadata: IGridColumnMetadata, model: any, property: string, options: any): string;
    finalTypeInPath(path: string): string;
    propertyFromPath(path: string): string;
    getValueProperty(object: any, metadata: IMetadataProperty): any;
    getValuePropertyKey(cell: ISelectedCell): string;
    getTextPropertyKey(cell: ISelectedCell): string;
}
interface ValidatorOptions {
    message: string;
    allowNull: boolean;
}
declare type Validator = (newValue: any, validatorOptions: ValidatorOptions) => any;
interface IKnockoutValidators {
    createValidator: (validator: Validator, defaultMessage: string) => (value: any, validatorOptions: ValidatorOptions) => any;
    isValidAlias: (value: string, validatorOptions: ValidatorOptions) => boolean;
    isValidNumeric: (value: any, validatorOptions: ValidatorOptions) => boolean;
    isValidInteger: (value: any, validatorOptions: ValidatorOptions) => boolean;
    isNotNullOrEmpty: (value: any, validatorOptions: ValidatorOptions) => boolean;
    isValidDateFormat: (value: string, validatorOptions: ValidatorOptions) => boolean;
    isValidTimeFormat: (value: string, validatorOptions: ValidatorOptions) => boolean;
    isValidNumericFormat: (value: string, validatorOptions: ValidatorOptions) => boolean;
    isValidIntegerFormat: (value: string, validatorOptions: ValidatorOptions) => boolean;
}
interface IValueWithUnit {
    Unit: string;
    Value: number;
}
interface IEnum {
    Text: string;
    Value: string;
}
interface ISelectedCell {
    column: GridColumn;
    originalValue: any;
    row: GridItem;
    value: KnockoutObservableValue<any>;
}
interface IToken {
    start: number;
    end: number;
    string: string;
    type: string;
    state: any;
}
interface IFormattingCulture {
    Name: string;
    DateFormats: string[];
    DateTimeFormats: string[];
}
interface IOptions {
    explorerHostUrl: string;
    username: string;
    languageCulture: string;
    languageCultures: string[];
    formattingCulture: string;
    formattingCultures: IFormattingCulture[];
    derivedTimezone: string;
    timezone: string;
    timezones: string[];
    dateTimeDisplayFormat: string;
    dateDisplayFormat: string;
    sessionTimeoutEnabled: boolean;
    resources: IDictionary<string>;
    userCanEditViews: boolean;
    [index: string]: any;
}
interface ITitle {
    setTitle: (title: KnockoutObservable<string> | string) => void;
    clearTitle: () => void;
}
interface IDashboardOptions extends IOptions {
    userCanCreateDashboards: boolean;
    userCanEditDashboards: boolean;
    isAzureMembershipActive: boolean;
    areAzureADSettingsPresentInConfig: boolean;
}
interface Aggregate {
    Key: string;
    Values: (SingleAggregate | MultiAggregate)[];
}
interface AggregateValue {
    TotalAggregate: number;
    Function: string;
}
interface SingleAggregate extends AggregateValue {
    Property: string;
    PropertyPath: string;
    IsValueWithUnitProperty: boolean;
}
interface MultiAggregate extends AggregateValue {
    Properties: SingleAggregate[];
}
interface GridAggregatesParams {
    columns: KnockoutComputed<GridColumn[]>;
    aggregates: KnockoutObservableArray<Aggregate>;
    aggregateRowsSelected: KnockoutObservableArray<number>;
}
interface GridRowParams {
    columns: KnockoutComputed<GridColumn[]>;
    row: GridItem;
    typeMetadata: ITypeMetadata;
    validationInDisplayMode?: boolean;
    gridDisabled: KnockoutObservable<boolean>;
    gridId: string;
    highlight: KnockoutObservable<boolean>;
}
interface GridCellParams {
    column: GridColumn;
    row: GridItem;
    typeMetadata: ITypeMetadata;
    gridId: string;
    gridDisabled: KnockoutObservable<boolean>;
    onRender?: (position: number) => void;
    customClasses?: string;
}
interface DashboardParams {
    elementId: string;
    dashboardName?: KnockoutObservable<string>;
}
interface TileParams {
    config: ITileConfig;
    tile: ITile;
    tileType: ITileType;
    dashboardInEditMode: KnockoutObservable<boolean>;
    dashboardElementId: string;
}
interface ITileType {
    isCustomTile: boolean;
    tileTypeName: string;
    displayName: string;
    typeName: string;
    tileDefinition: ITileDefinition;
    defaultTile: ITileBase;
    requiresAzureLogin: boolean;
    hasLinkedTile: boolean;
}
interface IDashboard {
    Id: number;
    Name: string;
    Tiles: ITile[];
}
interface ITileConfig {
    gutterWidth: number;
    gridItemWidth: number;
    gridItemHeight: number;
    tileContentMarginSize: number;
}
interface ITileBase {
    $type: string;
    Id: string;
    Title: string;
    Subtitle: string;
    DisplayTitle: boolean;
    DisplaySubtitle: boolean;
    PositionX: number;
    PositionY: number;
    SizeX: number;
    SizeY: number;
}
interface ITile extends ITileBase {
    TileType: string;
    Content: string;
}
interface IHaveLinkedTile {
    LinkedTileId: string;
}
interface ITileDefinition {
    $type: string;
    DisplayName: string;
    Name: string;
    Component: string;
    DefaultSizeX: number;
    DefaultSizeY: number;
    MinSizeX: number;
    MinSizeY: number;
    MaxSizeX: number;
    MaxSizeY: number;
}
interface ITileViewModel {
    positionX: KnockoutObservable<number>;
    positionY: KnockoutObservable<number>;
    width: KnockoutObservable<number>;
    height: KnockoutObservable<number>;
    resizeDisabled: boolean;
    resizeEnabled: boolean;
    tileObject: KnockoutComputed<ITile>;
    minWidth: number;
    minHeight: number;
    maxWidth: number;
    maxHeight: number;
    tileElement: Element;
    onResize: () => void;
}
interface ITileComponentParams {
    tile: ITileViewModel;
    contentAreaHeight: KnockoutObservable<number>;
    contentAreaWidth: KnockoutObservable<number>;
    tileConfig: ITileConfig;
    publish: (data: ILinkedTilePublishData) => void;
    receivePublishMethodObservable: KnockoutObservable<(data: ILinkedTilePublishData) => void>;
}
interface ILinkedTilePublishData {
    publishingTile: ITileBase;
    body: IDictionary<any>;
}
interface IMoveDragStartInfo {
    isMouseEvent: boolean;
    startEvent: MouseEvent | TouchEvent;
    startScrollLeft: number;
    startScrollTop: number;
    startPointerX: number;
    startPointerY: number;
    startX: number;
    startY: number;
    currentX: number;
    currentY: number;
    moveHelper: HTMLDivElement;
}
interface IResizeDragStartInfo {
    isMouseEvent: boolean;
    startEvent: MouseEvent | TouchEvent;
    startHeightPixels: number;
    startWidthPixels: number;
    startHeight: number;
    startWidth: number;
    startPointerX: number;
    startPointerY: number;
    currentHeight: number;
    currentWidth: number;
    resizeHelper: HTMLDivElement;
}
interface IPowerBIRenderParams {
    accessToken: string;
    embedUrl: string;
    autoRefreshTime: number;
    width: KnockoutObservable<number>;
    height: KnockoutObservable<number>;
}
interface IPowerBIReportRenderParams extends IPowerBIRenderParams {
    hideFilterPanelInReport?: boolean;
}
interface IPowerBITileForRender {
    accessToken: string;
    embedUrl: string;
    id: string;
    title: string;
}
interface IPowerBIReportForRender extends IPowerBITileForRender {
    webUrl: string;
}
interface IViewTile extends ITileBase {
    ViewId: number;
    ShowParameterBar: boolean;
}
interface ITextTile extends ITileBase {
    Content: string;
}
interface IParameterBarTile extends ITileBase {
    DataService: string;
    BaseType: string;
    Parameters: SelectedParameter[];
    ParameterValues: SelectedParameterValue[];
}
interface IValidations {
    add: (validation: KnockoutObservable<boolean>) => void;
    isValid: KnockoutComputed<boolean>;
    messages: IDictionary<KnockoutObservable<string>>;
}
interface IPanelEntity {
    record: IHaveId | IHaveId[];
    observables: IDictionary<KnockoutObservableValue<any>>;
    validations: IValidations;
    state: IPanelState;
}
interface IConfirmActionParams extends IHaveId {
    actionUrl: string;
    title: string;
    question: string;
    warning: string;
    success: string;
    yesCaption?: string;
    noCaption?: string;
}
interface IOnCompletionParams {
    record: any;
    state: IPanelState;
}
interface IPanelState {
    [index: string]: any;
    _stackId: number;
    action: string;
    component: string;
    dataService?: string;
    dataServiceUrl?: string;
    gridId?: string;
    isCreate: boolean;
    isWide: KnockoutObservable<boolean>;
    onCompletion: (entity: IOnCompletionParams) => void;
    parentIsSource: boolean;
    requiresUpdate: boolean;
    resizeDisabled: boolean;
    typeName?: string;
    customConfirm?: (current: IPanelEntity, metadata: ITypeMetadata, errorMessages: KnockoutObservableArray<string>, closePanelCallback: () => void) => boolean;
}
interface IActionArgs {
    action: string;
    component: string;
    baseType: string;
    dataService: string;
    dataServiceUrl?: string;
    enqueue?: boolean;
    isWidePane?: boolean;
    metadata?: ITypeMetadata;
    onCompletion?: (record: any) => void;
    parentIsSource?: boolean;
    preserveStack?: boolean;
    resizeDisabled?: boolean;
    data?: IHaveId | IHaveId[];
    toEdit?: IHaveId[];
    toDelete?: IHaveId[];
    toLock?: IHaveId[];
    selectedParameterValues?: KnockoutObservableArray<SelectedParameterValue>;
    customConfirm?: (current: IPanelEntity, metadata: ITypeMetadata, errorMessages: KnockoutObservableArray<string>, closePanelCallback: () => void) => boolean;
}
interface ITypePermissions {
    permissionsToCreate: IDictionary<boolean>;
    permissionsToEdit: IDictionary<boolean>;
    permissionsToDelete: IDictionary<boolean>;
    subTypes: IDictionary<string[]>;
    subTypeDisplayNames: IDictionary<string[]>;
    lockPermissionType: string;
    lockable: boolean;
}
interface IComponentParams {
    model: IPanelEntity;
    metadata?: IMetadataProperty;
    typeMetadata: ITypeMetadata;
    permissions?: ITypePermissions;
    grid: string;
    errorMessages: KnockoutObservableArray<string>;
    sendPowerBiTokenWithRequests?: boolean;
}
interface IAvailablePropertiesParams {
    instanceName: string;
    baseType: KnockoutObservable<string>;
    dataService: KnockoutObservable<string>;
    formDisabled: KnockoutObservable<boolean>;
    renderedState?: KnockoutObservableArray<KnockoutObservable<boolean>>;
    isCreate: boolean;
    model?: IPanelEntity;
}
interface IAvailablePermissonsParams {
    instanceName: string;
    model: IPanelEntity;
    permissionType: "DataLevelPermission" | "ServiceLevelPermission";
    availablePermissions: IDictionary<IDictionary<string[]>>;
}
interface IHelp {
    showHelp: KnockoutObservable<boolean>;
    toggleHelpText: KnockoutComputed<string>;
    openHelp: (product: string, module: string, item: string, data: any) => void;
    toggleHelp: () => void;
}
interface IHaveId {
    Id: any;
}
interface IRecordWithSummary {
    record: IHaveId;
    identificationSummary: string;
}
interface IRecordValidation {
}
interface IViewGridRecordsData {
    records: KnockoutObservableArray<GridItem>;
    totalCount: KnockoutObservable<number>;
}
interface IViewGridBaseConfig {
    disableEditMode?: boolean;
    disableParamsBar?: boolean;
    isEmbedded?: boolean;
    gridRendered?: (viewGrid: IViewGridRecordsData) => void;
    loadTransientNotificationsModule?: boolean;
    showParamsBar?: boolean;
    showViewTitle?: boolean;
    viewGridId: string;
}
interface IViewGridData extends IViewGridBaseConfig {
    aggregatesAtTop?: boolean;
    aggregatesAtBottom?: boolean;
    initialiseNewRecord?: (record: any) => void;
}
interface IBlockingMessageConfig {
    hasSpinner: boolean;
    heading: KnockoutObservable<string>;
    message: KnockoutObservable<string>;
    visible: KnockoutObservable<boolean>;
    viewGridId: string;
}
interface ILoadViewDataBase {
    customButtons?: CustomButton[];
    enableQuerying?: boolean;
    urlFilteredby?: UrlFilteredBy[];
    viewName: string;
}
interface ILoadViewData extends ILoadViewDataBase {
    urlAggregates?: UrlAggregate[];
    disableEditMode?: boolean;
    applyCustomColumnHeaders?: (columns: GridColumn[]) => void;
    urlParameters?: UrlParameter[];
}
interface ParameterBarBaseConfig {
    disableParamsBar: KnockoutObservable<boolean>;
    forceQueryRefresh: () => void;
    enableQuerying: KnockoutObservable<boolean>;
    metadata: KnockoutObservable<ITypeMetadata>;
    parameterBarRendered: KnockoutObservable<boolean>;
    selectedParameters: KnockoutObservableArray<SelectedParameter>;
    selectedParameterValues: KnockoutObservableArray<SelectedParameterValue>;
    viewGridId: string;
    viewId: number;
    urlParameters?: UrlParameter[];
    urlFilteredBys?: UrlFilteredBy[];
}
interface ParameterBarConfig extends ParameterBarBaseConfig {
    explorerDataService: string;
    explorerHostUrl: string;
}
interface ParameterValue {
    text: string;
    value: string | number;
    used: boolean;
}
interface ParameterFragment {
    isNullOrEmpty: boolean;
    queryString: string;
}
interface IParameterViewModelParams {
    component: string;
    inEditMode: KnockoutObservable<boolean>;
    metadata: IMetadataProperty;
    parameter: SelectedParameter;
    ready: (vm: IParameterViewModel) => void;
    startEditing: () => void;
    viewGridId: string;
}
interface IParameterViewModel {
    controlId: string;
    id: number;
    field: string;
    operator: string;
    type: string;
    selectedValues: KnockoutObservable<string[]>;
    includeEmpty: KnockoutObservable<boolean>;
    metadata: IMetadataProperty;
    addValue: (value: string | number) => void;
    loadValuesFromUrl(parameters: UrlParameter[]): any;
    resetToPrevious: () => void;
    savePreviousValues: () => void;
}
interface IParameterControl {
    focus(): void;
    open(): void;
    destroy(): void;
    bind(eventName: string, handler: Function): kendo.Observable;
}
interface IUpdateGridData {
    updateTimestamp: number;
    viewName: string;
    viewId: number;
    metadata: ITypeMetadata;
    baseType: string;
    dataService: string;
    url: string;
    filter: string;
    orderby: string[];
    disableEditMode: boolean;
    selectedColumns: SelectedColumn[];
    urlAggregates: UrlAggregate[];
    customButtons: any[];
}
interface IDimensions {
    height: KnockoutObservable<number>;
    width: KnockoutObservable<number>;
}
interface BaseQueryResult {
    TotalCount: number;
    Query: string;
}
interface QueryResult<T> extends BaseQueryResult {
    Records: T[];
    Aggregates: Aggregate[];
}
interface LiveQueryResult<T> extends BaseQueryResult {
    QueryId: string;
    Records: DataServiceRecord<T>[];
    Aggregates: Aggregate[];
}
interface BaseLiveQueryChangesResult<FieldChangeType> {
    Case: "None" | "Some";
    Fields: {
        Case: "RecordCacheItem" | "AggregationCacheItem";
        Fields: FieldChangeType[];
    }[];
}
interface LiveQueryChangesResult<T> extends BaseLiveQueryChangesResult<LiveQueryResultChanges<T>> {
}
interface AggregationLiveQueryChangesResult extends BaseLiveQueryChangesResult<AggregationLiveQueryResultChanges> {
}
interface AggregateChangeDetails {
    Aggregate: Aggregate;
    ChangedAggregates: string[];
    Property: string;
}
interface BaseChangedRecord<T> {
    ChangedProperties: string[];
    Record: T;
    ResultType: "Added" | "Removed" | "Updated";
}
interface ChangedRecord<T> extends BaseChangedRecord<DataServiceRecord<T>> {
}
interface ChangedAggregationRecord extends BaseChangedRecord<FlattenedAggregationRecord> {
}
interface BaseRecord {
    BaseTypeName: string;
    Position: number;
    TypeName: any;
    Id?: string;
}
interface DataServiceRecord<T> extends BaseRecord {
    Data: T;
}
interface FlattenedAggregationRecord extends BaseRecord {
    AggregationRowType: IEnum;
    GroupedBy: IKeyValuePair<string, any>[];
    Aggregations: IKeyValuePair<string, any>[];
}
interface FlattenedAggregationQueryResult extends BaseQueryResult {
    Aggregations: FlattenedAggregationRecord[];
}
interface FlattenedAggregationLiveQueryResult extends FlattenedAggregationQueryResult {
    QueryId: string;
}
interface BaseLiveQueryResultChanges {
    TotalCount: number;
    ReplaceAll: boolean;
}
interface LiveQueryResultChanges<T> extends BaseLiveQueryResultChanges {
    AggregateChanges: AggregateChangeDetails[];
    RecordChanges: ChangedRecord<T>[];
}
interface AggregationLiveQueryResultChanges extends BaseLiveQueryResultChanges {
    AggregationChanges: ChangedAggregationRecord[];
}
interface IException {
    fullException: any;
    message: string;
}
interface MessageSet {
    Messages: string[];
    Summary: string;
    Type: string;
}
interface ModelValidation {
    ModelValidations: string[];
    PropertyValidations: IDictionary<string>;
    Summary: string;
    Type: string;
}
interface ChangeSetResult {
    FailedCreates: IDictionary<ModelValidation | MessageSet>;
    FailedDeletions: IDictionary<ModelValidation | MessageSet>;
    FailedUpdates: IDictionary<ModelValidation | MessageSet>;
    SuccessfullyCreated: IDictionary<any>;
    SuccessfullyDeleted: any[];
    SuccessfullyUpdated: any[];
}
interface ChangeResult {
    Failure: MessageSet;
    WasSuccessful: boolean;
}
interface ChangeResultWithItem<T> extends ChangeResult {
    Item: T;
}
interface IValidationCellConfig {
    columns: KnockoutComputed<GridColumn[]>;
    row: GridItem;
}
interface IGridFlags {
    aggregatesAtTop: boolean;
    inEditMode: KnockoutObservable<boolean>;
}
interface IGridView {
    Id: number;
    Name: string;
}
declare type LiveQueryApi = "query" | "aggregationquery" | "timeseriesquery";
interface IGridQueryManager {
    dispose: () => void;
    refresh: () => JQueryPromise<void>;
}
interface GridConfiguration {
    aggregates?: KnockoutObservableArray<Aggregate>;
    aggregatesPosition?: KnockoutObservable<string>;
    canSelectIndividualCells?: KnockoutObservable<boolean>;
    createNewRecord?: () => GridItem;
    disabled?: KnockoutObservable<boolean>;
    disableGridSorting: KnockoutObservable<boolean>;
    disableInsertRecords?: boolean;
    disableRemoveRecords?: boolean;
    disableSoftDelete?: boolean;
    embedded?: boolean;
    flags?: ViewGridFlags;
    footer: OptionalComponent;
    header: OptionalComponent;
    inEditMode?: KnockoutObservable<boolean>;
    isView: boolean;
    metadata: KnockoutObservable<ITypeMetadata>;
    orderedBy?: KnockoutObservableArray<string>;
    postRender?: () => any;
    records: KnockoutObservableArray<GridItem>;
    recordsCount: KnockoutComputed<number>;
    showValidationInDisplayMode?: boolean;
    selectedColumns: KnockoutComputed<GridColumn[]>;
    selectedRecords: KnockoutComputed<GridItem[]>;
    updateDirtyRecordWithLatestValues?: (item: GridItem, columns: GridColumn[]) => void;
    validate?(record: GridItem, successCallback: (record: GridItem, model: IHaveId) => void, failureCallback: (record: GridItem, validation: ModelValidation) => void): any;
    view?: IGridView;
    viewGridId?: string;
}
interface GridContext {
    activeGridClass: string;
    config: GridConfiguration;
    copyPasteTextAreaClass: string;
    element: string;
    flags: ViewGridFlags;
    maxRows: number;
    viewGridId: string;
    activeElement: KnockoutObservable<Element>;
    canInsertRows: KnockoutComputed<boolean>;
    canSelectIndividualCells: KnockoutObservable<boolean>;
    columns: KnockoutComputed<GridColumn[]>;
    inEditMode: KnockoutObservable<boolean>;
    originSelectedCell: KnockoutObservable<ISelectedCell>;
    recordsCount: KnockoutComputed<number>;
    rows: KnockoutComputed<GridItem[]>;
    selectedRows: KnockoutComputed<GridItem[]>;
    userSelectedCells: KnockoutComputed<ISelectedCell[]>;
    clearSelected: () => void;
    insertRecord: (insertAbove?: boolean) => GridItem;
    insertRecordAtBottom: () => GridItem;
    isActiveGrid: () => void;
    previousCellFrom: (column: number, row: number) => any;
    nextCellFrom: (column: number, row: number) => any;
    removeRecords: () => void;
    selectCellAt: (column: number, row: number, selectMultiple?: boolean) => void;
    selectionChanged: () => void;
    updateDirtyRecordWithLatestValues: (item: GridItem, columns: GridColumn[]) => void;
    validate: (item: any, success: any, failure: any) => void;
    validationOnSuccess: (row: GridItem, record: any) => void;
}
interface GridColumn {
    accessor: (record: GridItem) => any;
    colSpan: (record: GridItem) => number;
    displayClasses: (item: GridItem) => string;
    displayName: KnockoutObservable<string>;
    formatter: (value: any) => string;
    metadata: IGridColumnMetadata;
    path: string;
    position: KnockoutObservable<number>;
    hoverTitleContent?: string;
}
interface ExplorerGridItemOptionalParameters {
    /** update type for the grid item
     * default = 'None'
     */
    updateType?: "Added" | "Removed" | "Updated" | "Deleted" | "None";
    /** Should the row be highighted when added (to signify created record)
     * default = false
     */
    doHighlight?: boolean;
    /** disable change tracking (coloured backgrounds for modified/new grid item)
     * default = false
     */
    disableChangeTracking?: boolean;
    /** disable validate on change for grid item values
     * default = false
     */
    disableValidateOnChange?: boolean;
}
declare type ValidationResult = ModelValidation | IException | MessageSet;
interface GridItem {
    baseTypeName: string;
    bwfId: string;
    dirtyRecord: any;
    isChangeTrackingDisabled: boolean;
    isValidateOnChangeDisabled: boolean;
    editable: boolean;
    id: number | string;
    metadata: ITypeMetadata;
    modelValidations: KnockoutObservableArray<string>;
    position: KnockoutObservable<number>;
    queryPosition: KnockoutObservable<number>;
    record: any;
    selected: KnockoutObservable<boolean>;
    typeName: string;
    updateTime: number;
    highlight: KnockoutObservable<boolean>;
    doHighlight: () => void;
    updateType: KnockoutObservable<string>;
    values: IDictionary<KnockoutObservableValue<any>>;
    _destroy?: boolean;
    applyChangeSetResult: (result: ChangeSetResult) => void;
    applyLiveChanges: (changes: ChangedRecord<any>, columns?: GridColumn[]) => void;
    applyValidation: (validationResult: ValidationResult) => void;
    resetValidation: () => void;
    hasUnsavedChanges: KnockoutObservable<boolean>;
    hasValidationErrors: KnockoutComputed<boolean>;
    isNewRecord: KnockoutObservable<boolean>;
    configureColumns: (columns: GridColumn[]) => void;
    getRowComponent: (gridContext: GridContext) => KnockoutObservable<string>;
    getSelectedValues: () => IDictionary<KnockoutObservableValue<any>>;
}
interface IGridCell {
    row: GridItem;
    column: GridColumn;
    isEditable: KnockoutObservable<boolean>;
    isFocused: KnockoutComputed<boolean>;
    isSelected: KnockoutObservable<boolean>;
    isInCopyOrPasteGroup: KnockoutObservable<boolean>;
    isDirty: KnockoutComputed<boolean>;
    isValid: KnockoutObservable<boolean>;
    colSpan: number;
    doHighlight(): void;
    getClipboardValue(): string;
}
interface ViewGridFlags {
    applyInProgress: KnockoutObservable<boolean>;
    autoUpdatesEnabled: KnockoutObservable<boolean>;
    disableEditMode: KnockoutObservable<boolean>;
    disableParamsBar: KnockoutObservable<boolean>;
    enableQuerying: KnockoutObservable<boolean>;
    exportInProgress: KnockoutObservable<boolean>;
    pasteInProgress: KnockoutObservable<boolean>;
    inEditMode: KnockoutObservable<boolean>;
    isEmbedded: boolean;
    loadingView: KnockoutObservable<boolean>;
    loadTransientNotificationsModule: boolean;
    navigatingAway: boolean;
    panelVisible: KnockoutObservable<boolean>;
    parameterBarRendered: KnockoutObservable<boolean>;
    querying: KnockoutObservable<boolean>;
    rendered: KnockoutObservable<boolean>;
    showViewTitle: KnockoutObservable<boolean>;
    showParameterBar: KnockoutObservable<boolean>;
    supportsEditMode: KnockoutObservable<boolean>;
    disableGridSorting: KnockoutObservable<boolean>;
    widePanel: KnockoutObservable<boolean>;
}
interface OptionalComponent {
    enabled: KnockoutObservable<boolean>;
    name: string;
    config: any;
}
interface UrlParameter {
    Operator: string;
    Property: string;
    Value: string;
    Component?: string;
    AllowNull?: boolean;
    Alias?: string;
}
interface UrlFilteredBy {
    Operator: string;
    Property: string;
    Value: string;
    AllowNull?: boolean;
}
interface UrlAggregate {
    Method: string;
    Property: string;
    Property2?: string;
}
interface SelectedParameterValue {
    id: number;
    field: string;
    includeEmpty: boolean;
    position: number;
    operator: string;
    type: string;
    values: string[];
}
interface HeaderButton {
    Icon: string;
    Explanation: string;
    DisplayName: string;
    Position: number;
    InvokableFor?: number;
    InvokableForScript?: string;
}
interface CustomButton extends HeaderButton {
    Id: string;
    PostboxMessage: string;
    ButtonType?: string;
    Options?: string;
    Hidden?: KnockoutObservable<boolean>;
    Disabled?: KnockoutObservable<boolean>;
}
interface ActionButtonOption {
    DisplayName: string;
    Explanation: string;
    Value: string;
}
interface IndexlessStorage {
    length: number;
    clear(): void;
    getItem(key: string): any;
    removeItem(key: string): void;
    setItem(key: string, data: string): void;
}
interface INotificationService {
    Reset: () => void;
    newNotifications: KnockoutObservable<number>;
}
interface ITransientNotification {
    message: string;
    title?: string;
    styleClass?: string;
    requireDismissal?: boolean;
}
declare type TransientNotification = string | ITransientNotification;
interface Selection {
    BaseType: string;
    DataServiceSystem: string;
    Description: string;
    Filter: string;
    Id: number;
    Name: string;
    System: DataService;
}
interface Presentation {
    BaseType: string;
    BwfDescription: string;
    DataServiceSystem: string;
    Description: string;
    Id: number;
    Name: string;
    System: DataService;
}
interface SelectedColumn {
    Id: number;
    Name: string;
    Position: number;
    Alias: string;
    Format: string;
}
interface SelectedAggregation {
    Id: number;
    PropertyName: string;
    Function: IEnum;
    ExtraParameters?: string;
}
interface GridPresentation extends Presentation {
    DisableGridSorting: boolean;
    OrderBy: string;
    SelectedColumns: SelectedColumn[];
    Aggregations: SelectedAggregation[];
    AggregationsPosition: IEnum;
}
interface GroupingProperty {
    Id: number;
    Name: string;
    Position: number;
    NewLevel: boolean;
    Level?: number;
    IncludeSubtotals: boolean;
    Order: IEnum;
    Alias?: string;
    Format?: string;
}
interface GroupingAggregation {
    Id: number;
    Name: string;
    Position: number;
    Function: string;
    Options: IEnum;
    ExtraParameters?: string;
    Alias?: string;
    Format?: string;
}
interface Grouping {
    BaseType: string;
    BwfDescription: string;
    DataServiceSystem: string;
    Description: string;
    Id: number;
    Name: string;
    System: DataService;
    IncludeTotals: boolean;
    GroupByColumns: GroupingProperty[];
    Aggregations: GroupingAggregation[];
}
interface IGroupingDataItem {
    aggregationRowType: IEnum;
    level: number;
    groupedBy: IKeyValuePair<string, any>[];
    aggregations: IKeyValuePair<string, any>[];
}
interface IBreadcrumbConfig {
    breadcrumbs: KnockoutObservableArray<IBreadcrumbItem>;
    disabled?: KnockoutObservable<boolean>;
}
interface IBreadcrumbItem {
    displayName: string;
    description?: string;
    active?: boolean;
    data?: any[];
    onClick?: (item: IBreadcrumbItem) => void;
    url?: string;
}
interface IAggregationFunctionDefinition {
    Name: string;
    DisplayName: string;
    DefaultOption: string;
    ValidOptions: string[];
    UseResultPropertyTypeForTypes: string[];
    ResultPropertyType?: PropertyRecord;
}
interface DataService {
    Id: number;
    Name: string;
    System: string;
    Url: string;
}
interface DataServiceSummary {
    Name: string;
    Url: string;
    HasLocking: boolean;
    HasServiceLevelPermissions: boolean;
    HasDataLevelPermissions: boolean;
}
interface SelectedParameter {
    Id: number;
    Parameter: string;
    Operator: string;
    Position: number;
    Component?: string;
    AllowNullOrEmpty?: boolean;
    Alias?: string;
}
interface IViewParameterOption {
    Id?: number;
    Username: string;
    ViewId: number;
    SelectedParameterId: number;
    IncludeEmpty: boolean;
    Values: IViewParameterValue[];
}
interface IViewParameterValue {
    Id?: number;
    SelectedValue: string;
    Position: number;
}
interface View extends IGridView {
    DataServiceSystem: string;
    System: DataService;
    BaseType: string;
    Description: string;
    Selection: Selection;
    Presentation: Presentation;
    GridPresentation: GridPresentation;
    Grouping: Grouping;
    SelectedParameters: SelectedParameter[];
}
interface PermissionGroupDataLevelPermission {
    Id?: number;
    EntityType: string;
    PermissionName: string;
    EntityDescription: string;
    DataService: string;
}
interface PermissionGroupServiceLevelPermission {
    Id?: number;
    Type: string;
    Name: string;
    DataService: string;
}
interface PermissionGroup {
    Id: number;
    Name: string;
    Description: string;
    ServiceLevelPermissions: PermissionGroupServiceLevelPermission[];
    DataLevelPermissions: PermissionGroupDataLevelPermission[];
}
interface AddToSelectedPermissionsPublish {
    dataService: string;
    type: string;
    permissionName: string;
    entityId?: string;
}
interface FileUploadParameters {
    propertyObservable: KnockoutObservable<any>;
    isImageUpload: boolean;
    disable?: KnockoutObservable<boolean>;
    showBorder?: boolean;
    acceptFileTypes?: string;
    sizeLimit?: number;
}
interface ToastMessage extends IHaveId {
    Title: string;
    Message: string;
    Received: string;
    IsRead: boolean;
    Username: string;
}
interface IRecipient {
    Id?: number;
    Name: string;
    Fullname: string;
    Email: string;
    SourceId: string;
    Source: string;
}
interface INotificationRecipient {
    Recipient: IRecipient;
}
interface BwfRecordLock {
    EntityId: number;
    EntityType: string;
    Context: string;
    Reason: string;
    Username: string;
    Id?: number;
    TimeStamp?: string;
}
interface IQueryBuilder {
    Expand: (...properties: string[]) => IQueryBuilder;
    IncludeExpandsForEditing: () => IQueryBuilder;
    OrderBy: (property: string, ascending?: boolean) => IQueryBuilder;
    Filter(callback: (filterBuilder: IFilterBuilder) => void): IQueryBuilder;
    DistinctBy: (property: string) => IQueryBuilder;
    ExcludeTotalCount: () => IQueryBuilder;
    Top: (maxRecords: number) => IQueryBuilder;
    Skip: (toSkip: number) => IQueryBuilder;
    GroupBy: (property: string) => IQueryBuilder;
    Aggregate: (builder: (aggregateBuilder: IAggregateBuilder) => void) => IQueryBuilder;
    GroupByAggregate: (builder: (aggregateBuilder: IAggregateBuilder) => void) => IQueryBuilder;
    GetQuery: () => string;
}
interface IFilterBuilder {
    Property(property: string): IFilterOperator;
    And(subFilterSetup?: (x: IFilterBuilder) => void): IFilterBuilder;
    Or(subFilterSetup?: (x: IFilterBuilder) => void): IFilterBuilder;
    Parenthesis(subFilter: (x: IFilterBuilder) => IFilterBuilder): IFilterBuilder;
}
interface IFilterOperator {
    Like(item: string): IFilterBuilder;
    NotLike(item: string): IFilterBuilder;
    GreaterThan(item: any): IFilterBuilder;
    GreaterThanDate(item: any): IFilterBuilder;
    GreaterThanDateTime(item: any): IFilterBuilder;
    GreaterThanEqualTo(item: any): IFilterBuilder;
    GreaterThanEqualToDate(item: any): IFilterBuilder;
    GreaterThanEqualToDateTime(item: any): IFilterBuilder;
    LessThan(item: any): IFilterBuilder;
    LessThanDate(item: any): IFilterBuilder;
    LessThanDateTime(item: any): IFilterBuilder;
    LessThanEqualTo(item: any): IFilterBuilder;
    LessThanEqualToDate(item: any): IFilterBuilder;
    LessThanEqualToDateTime(item: any): IFilterBuilder;
    EqualTo(item: any): IFilterBuilder;
    EqualToDate(item: any): IFilterBuilder;
    EqualToDateTime(item: any): IFilterBuilder;
    NotEqualTo(item: any): IFilterBuilder;
    NotEqualToDate(item: any): IFilterBuilder;
    NotEqualToDateTime(item: any): IFilterBuilder;
    IsNull(): IFilterBuilder;
    IsNotNull(): IFilterBuilder;
    In(...items: string[]): IFilterBuilder;
}
interface IAggregateBuilder {
    Sum(property: string): IAggregateBuilder;
    Min(property: string): IAggregateBuilder;
    Max(property: string): IAggregateBuilder;
    Average(property: string): IAggregateBuilder;
    WeightedAverage(property1: string, property2: string): IAggregateBuilder;
    Count(property: string): IAggregateBuilder;
}
interface IDataServiceClient {
    create<T>(item: T, type: string, dataService?: string, requeryCreated?: boolean): JQueryPromise<ChangeResultWithItem<T>>;
    update<T>(item: T, type: string, dataService?: string, requeryUpdated?: boolean): JQueryPromise<ChangeResultWithItem<T>>;
    delete(id: any, type: string, dataService?: string): JQueryPromise<void>;
    processChangeSet(changeSet: any, type: string, dataService?: string): JQueryPromise<ChangeSetResult>;
    get<T>(id: any, type: string, dataService?: string): JQueryPromise<T>;
    getMetadataForType(type: string, dataService?: string): JQueryPromise<ITypeMetadata>;
    query<T>(queryString: string, dataService?: string): JQueryPromise<QueryResult<T>>;
    lock(id: any, context: string, reason: string, itemType: string): JQueryPromise<void>;
    unlock(id: any, itemType: string, context: string): JQueryPromise<void>;
    startLiveQuery(query: string, changesCallback: (changes, replaceAll: boolean) => void, dataService?: string): JQueryPromise<ILiveQueryInitialResponse>;
    killLiveQuery(queryId: string): any;
    getTypesForDataService(dataServiceName: string): JQueryPromise<IAvailableType[]>;
    dispose(): any;
}
interface ILoginResponse {
    token: string;
    error: string;
}
interface IAvailableType {
    Type: string;
    DisplayName: string;
    PluralisedDisplayName: string;
    AllowsExport: boolean;
    AllowsAutoUpdate: boolean;
    IsHidden: boolean;
    SupportedImportFormats: string[];
}
interface IChangeSet {
    Context?: IDictionary<string>;
    CreateVisibleToRoleIds?: {
        [key: number]: number[];
    };
    CreateEditableByRoleIds?: {
        [key: number]: number[];
    };
    Create?: {
        [key: number]: any;
    };
    Update?: {
        [key: string]: any;
    };
    Delete?: any[];
}
interface ILiveQueryInitialResponse {
    QueryId: string;
    Records: any[];
}
interface KnockoutObservableValue<T> extends KnockoutObservable<T> {
    isSelected?: KnockoutObservable<boolean>;
    isValid?: KnockoutObservable<boolean>;
    isDirty?: KnockoutComputed<boolean>;
    resetIsDirty?: () => void;
    validationMessage?: string;
    validationMessages?: KnockoutObservableArray<string>;
    isInCopyOrPasteGroup?: KnockoutObservable<boolean>;
    colSpan?: number;
    isReadonly?: KnockoutObservable<boolean>;
}
interface KnockoutComputedValue<T> extends KnockoutObservableValue<T>, KnockoutComputed<T> {
    extend(requestedExtenders: {
        [key: string]: any;
    }): KnockoutComputed<T>;
}
interface KnockoutBindingHandlers {
    highlightUpdates?: KnockoutBindingHandler;
    anchorClick: KnockoutBindingHandler;
    readonly: KnockoutBindingHandler;
    interactable: KnockoutBindingHandler;
    draggable: KnockoutBindingHandler;
    markdownEditor: KnockoutBindingHandler;
    clipboardButton: KnockoutBindingHandler;
    bootstrapSelect: KnockoutBindingHandler;
}
interface Operator {
    DisplayName: string;
    Value: string;
}
interface Direction {
    DisplayName: string;
    Value: string;
}
interface Window {
    clipboardData: ClipboardData;
}
interface ClipboardData {
    getData: (type: string) => string;
}
interface IRssFeed {
    url: string;
    keywords: string;
}
interface IRssItem {
    title: string;
    description: string;
    pubDate: string;
    link: string;
}
interface IParsedParameters {
    urlParameters: UrlParameter[];
    urlFilteredby: UrlFilteredBy[];
}
declare module 'knockout-kendo' {
    var knockoutKendo: {};
    export = knockoutKendo;
}
declare module "options" {
    var o: IOptions;
    export = o;
}
declare module 'clipboard' {
    class Clipboard {
        constructor(trigger: string | HTMLElement | HTMLCollection | NodeList, options?: Object);
        on: (name: string, callback: any, ctx?: any) => void;
    }
    export = Clipboard;
}
declare module 'modules/ds-explorer-tiles;cc-basePowerBiTile' {
    class BasePowerBiTile {
        content: KnockoutComputed<string>;
        height: KnockoutObservable<number>;
        width: KnockoutObservable<number>;
        heightString: KnockoutComputed<string>;
        widthString: KnockoutComputed<string>;
        readyToRender: KnockoutObservable<boolean>;
        hasErrored: KnockoutObservable<boolean>;
        errorMessage: KnockoutObservable<string>;
        accessToken: KnockoutObservable<string>;
        embedUrl: KnockoutObservable<string>;
        redirectToDashboardUrl: KnockoutComputed<string>;
        tileConfig: ITileConfig;
        constructor(params: ITileComponentParams);
        requestSuccess(data: IPowerBITileForRender): any;
        requestFailure(failure: JQueryXHR): any;
        getAccessTokenHeader(): IDictionary<string>;
    }
}
declare module 'modules/ds-explorer-tiles;cc-rssTileBase' {
    class RssTileBase {
        protected feed: IRssFeed;
        private items;
        private pollingInterval;
        constructor(params: ITileComponentParams);
        protected updateFeed(feed: IRssFeed): any;
        dispose(): any;
    }
}
declare module 'modules/ds-explorer-tiles;cc-viewTileBase' {
    class ViewTileBase {
        options: IOptions;
        viewId: KnockoutObservable<number>;
        viewGridId: KnockoutObservable<string>;
        viewName: KnockoutObservable<string>;
        enableParameterBar: boolean;
        showParameterBar: boolean;
        canLoadView: KnockoutObservable<boolean>;
        viewQueryCompleted: KnockoutObservable<boolean>;
        availableHeight: KnockoutObservable<number>;
        availableWidth: KnockoutObservable<number>;
        subscriptions: KnockoutObservableArray<KnockoutSubscription>;
        tileComponentParams: ITileComponentParams;
        tileContent: any;
        tile: ITile;
        inTouchMode: KnockoutComputed<boolean>;
        linkedTileId: KnockoutObservable<string>;
        tileViewGridRendered: () => void;
        constructor(params: ITileComponentParams);
        protected getViewParameters(data: IDictionary<any>): UrlFilteredBy[];
        dispose(): any;
        onResize(): any;
    }
}
declare module 'scripts/sprintf' {
    function sprintf(fmt: string, ...args: any[]): string;
    function vsprintf(fmt: string, args: any[]): string;
}
